(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[185],{9046:function(e,n,t){Promise.resolve().then(t.t.bind(t,4811,23)),Promise.resolve().then(t.t.bind(t,2778,23)),Promise.resolve().then(t.bind(t,5321))},5321:function(e,n,t){"use strict";var o=t(7437),r=t(2265);n.default=()=>{let e=(0,r.useRef)(null),n=(0,r.useRef)(),t=(0,r.useRef)({x:.5,y:.5}),a=(0,r.useRef)({x:.5,y:.5});return(0,r.useEffect)(()=>{let o=e.current;if(!o)return;let r=o.getContext("webgl");if(!r){console.warn("WebGL not supported, falling back to CSS background");return}let i=(e,n,t)=>{let o=e.createShader(n);return o?(e.shaderSource(o,t),e.compileShader(o),e.getShaderParameter(o,e.COMPILE_STATUS))?o:(console.error("Shader compilation error:",e.getShaderInfoLog(o)),e.deleteShader(o),null):null},l=i(r,r.VERTEX_SHADER,"\n      attribute vec2 a_position;\n      varying vec2 v_uv;\n      \n      void main() {\n        v_uv = a_position * 0.5 + 0.5;\n        gl_Position = vec4(a_position, 0.0, 1.0);\n      }\n    "),s=i(r,r.FRAGMENT_SHADER,"\n      precision mediump float;\n      varying vec2 v_uv;\n      uniform float u_time;\n      uniform vec2 u_resolution;\n      uniform vec2 u_mouse;\n      \n      // Improved noise function for smoother gradients\n      float random(vec2 st) {\n        return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n      }\n      \n      float noise(vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n        \n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n        \n        vec2 u = f * f * (3.0 - 2.0 * f);\n        \n        return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n      }\n      \n      // Enhanced FBM for flowing plasma effect\n      float fbm(vec2 st, float time) {\n        float value = 0.0;\n        float amplitude = 0.5;\n        \n        // Add time-based offset for flow\n        st += time * vec2(0.1, 0.05);\n        \n        for (int i = 0; i < 6; i++) {\n          value += amplitude * noise(st);\n          st *= 2.0;\n          amplitude *= 0.5;\n        }\n        return value;\n      }\n      \n      // Domain warping for organic distortion\n      vec2 domainWarp(vec2 st, float time) {\n        float warpStrength = 0.3;\n        return st + warpStrength * vec2(\n          fbm(st + vec2(0.0, time * 0.1), time),\n          fbm(st + vec2(time * 0.12, 0.0), time)\n        );\n      }\n      \n      void main() {\n        vec2 st = v_uv;\n        vec2 normalizedCoord = gl_FragCoord.xy / u_resolution;\n        \n        // Center coordinates\n        vec2 pos = normalizedCoord - 0.5;\n        pos.x *= u_resolution.x / u_resolution.y;\n        \n        // Mouse interaction - create elastic pull effect\n        vec2 mousePos = u_mouse - 0.5;\n        mousePos.x *= u_resolution.x / u_resolution.y;\n        \n        // Calculate distance from center to mouse\n        float mouseDistance = length(mousePos);\n        vec2 mouseDirection = normalize(mousePos);\n        \n        // Create elastic offset - blob follows mouse but springs back\n        float pullStrength = 0.15; // How much the blob moves toward mouse\n        float maxPull = 0.3; // Maximum displacement\n        vec2 elasticOffset = mouseDirection * min(mouseDistance * pullStrength, maxPull);\n        \n        // Apply smooth falloff so effect is strongest at center\n        float centerInfluence = 1.0 - smoothstep(0.0, 0.8, length(pos));\n        elasticOffset *= centerInfluence;\n        \n        // Offset the position for mouse interaction\n        vec2 interactivePos = pos - elasticOffset;\n        \n        // Apply domain warping for organic flow using interactive position\n        vec2 warpedPos = domainWarp(interactivePos * 2.0, u_time * 0.2);\n        \n        // Multiple flowing noise layers for plasma effect\n        float plasma1 = fbm(warpedPos * 1.5 + u_time * 0.08, u_time);\n        float plasma2 = fbm(warpedPos * 2.3 + u_time * 0.12, u_time + 100.0);\n        float plasma3 = fbm(warpedPos * 3.1 + u_time * 0.15, u_time + 200.0);\n        \n        // Combine plasma layers\n        float combinedPlasma = plasma1 * 0.5 + plasma2 * 0.3 + plasma3 * 0.2;\n        \n        // Add radial falloff for subtle background gradient (using interactive position)\n        float centerDistance = length(interactivePos);\n        float radialFalloff = 1.0 - smoothstep(0.0, 1.8, centerDistance);\n        \n        // Apply breathing effect\n        float breathe = 0.9 + 0.2 * sin(u_time * 0.3);\n        radialFalloff *= breathe;\n        \n        // Remove corner shrinking for full screen coverage\n        // Keep the organic distortion but make it more subtle (using interactive position)\n        float ballDistortion = sin(atan(interactivePos.y, interactivePos.x) * 3.0 + u_time * 0.15) * 0.1;\n        ballDistortion += sin(atan(interactivePos.y, interactivePos.x) * 5.0 + u_time * 0.1) * 0.05;\n        float distortedRadius = centerDistance + ballDistortion * 0.3;\n        float organicGlow = 1.0 - smoothstep(0.3, 1.5, distortedRadius);\n        radialFalloff *= (0.3 + organicGlow * 0.7);\n        \n        // Create flowing heat zones with much subtler intensity\n        float heatZone1 = sin(combinedPlasma * 6.28 + u_time * 0.3) * 0.3 + 0.4;\n        float heatZone2 = sin(combinedPlasma * 8.0 + u_time * 0.4 + 2.0) * 0.2 + 0.3;\n        float heatZone3 = sin(combinedPlasma * 4.0 + u_time * 0.25 + 4.0) * 0.15 + 0.25;\n        \n        // Much more subtle color mapping to match reference image\n        vec3 color1 = vec3(0.15, 0.05, 0.04) * heatZone1; // Dark red\n        vec3 color2 = vec3(0.25, 0.08, 0.06) * heatZone2; // Slightly brighter red\n        vec3 color3 = vec3(0.35, 0.12, 0.08) * heatZone3; // Medium red\n        \n        // Blend colors based on plasma values\n        vec3 plasmaColor = mix(color1, color2, smoothstep(0.2, 0.6, plasma1));\n        plasmaColor = mix(plasmaColor, color3, smoothstep(0.3, 0.7, plasma2));\n        \n        // Apply radial falloff but keep it very subtle for full screen coverage\n        plasmaColor *= radialFalloff * 0.8 + 0.3; // Always some base intensity\n        \n        // Add very subtle flowing highlights only near center\n        float edgeGlow = smoothstep(0.4, 0.7, combinedPlasma) * radialFalloff * 0.15;\n        plasmaColor += edgeGlow * vec3(0.4, 0.15, 0.1);\n        \n        // Darker base background to match reference\n        vec3 baseColor = vec3(0.05, 0.02, 0.015);\n        \n        // Combine everything with more prominent base color\n        vec3 finalColor = baseColor + plasmaColor;\n        \n        // Reduce noise intensity\n        float grain = noise(normalizedCoord * 150.0 + u_time * 0.05) * 0.01;\n        finalColor += grain;\n        \n        // Reduce vignette effect for more uniform coverage\n        float vignette = 1.0 - length(normalizedCoord - 0.5) * 0.2;\n        finalColor *= vignette;\n        \n        // Add ambient temperature variation\n        float ambient = 0.8 + 0.2 * sin(u_time * 0.1 + combinedPlasma * 2.0);\n        finalColor *= ambient;\n        \n        gl_FragColor = vec4(finalColor, 1.0);\n      }\n    ");if(!l||!s)return;let c=((e,n,t)=>{let o=e.createProgram();return o?(e.attachShader(o,n),e.attachShader(o,t),e.linkProgram(o),e.getProgramParameter(o,e.LINK_STATUS))?o:(console.error("Program linking error:",e.getProgramInfoLog(o)),e.deleteProgram(o),null):null})(r,l,s);if(!c)return;let m=r.createBuffer();r.bindBuffer(r.ARRAY_BUFFER,m),r.bufferData(r.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,1,1]),r.STATIC_DRAW);let u=r.getAttribLocation(c,"a_position"),f=r.getUniformLocation(c,"u_time"),d=r.getUniformLocation(c,"u_resolution"),v=r.getUniformLocation(c,"u_mouse"),p=()=>{let e=window.innerWidth,n=window.innerHeight;(o.width!==e||o.height!==n)&&(o.width=e,o.height=n,r.viewport(0,0,e,n))},g=e=>{p(),a.current.x+=(t.current.x-a.current.x)*.1,a.current.y+=(t.current.y-a.current.y)*.1,r.clearColor(0,0,0,1),r.clear(r.COLOR_BUFFER_BIT),r.useProgram(c),r.uniform1f(f,.001*e),r.uniform2f(d,o.width,o.height),r.uniform2f(v,a.current.x,a.current.y),r.enableVertexAttribArray(u),r.bindBuffer(r.ARRAY_BUFFER,m),r.vertexAttribPointer(u,2,r.FLOAT,!1,0,0),r.drawArrays(r.TRIANGLE_STRIP,0,4),n.current=requestAnimationFrame(g)};p(),g(0);let h=e=>{let n=o.getBoundingClientRect();t.current.x=(e.clientX-n.left)/n.width,t.current.y=1-(e.clientY-n.top)/n.height},b=()=>{t.current.x=.5,t.current.y=.5},_=()=>p();return window.addEventListener("resize",_),window.addEventListener("mousemove",h),window.addEventListener("mouseleave",b),()=>{window.removeEventListener("resize",_),window.removeEventListener("mousemove",h),window.removeEventListener("mouseleave",b),n.current&&cancelAnimationFrame(n.current)}},[]),(0,o.jsx)("canvas",{ref:e,className:"fixed top-0 left-0 w-full h-full pointer-events-none",style:{zIndex:1}})}},2778:function(){},4811:function(e){e.exports={style:{fontFamily:"'__Inter_e8ce0c', '__Inter_Fallback_e8ce0c'",fontStyle:"normal"},className:"__className_e8ce0c"}}},function(e){e.O(0,[2,971,117,744],function(){return e(e.s=9046)}),_N_E=e.O()}]);